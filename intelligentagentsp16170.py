# -*- coding: utf-8 -*-
"""IntelligentAgentsP16170.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BfpPVqMHOqwwatYb_sQfzX2AgrWaJ3--

# **ΠΑΝΕΠΙΣΤΗΜΕΙΟ ΠΕΙΡΑΙΩΣ**

***ΤΜΗΜΑ ΠΛΗΡΟΦΟΡΙΚΗΣ***


---
*ΕΞΕΤΑΣΤΙΚΗ ΙΟΥΝΙΟΥ 2021*

*Υλοποίηθηκε απο τον φοιτητή:*

*ΒΕΡΓΙΑΝΝΗ ΝΙΚΟΛΑΟ - Π16170*


---

# **Blocks World Problem**

To πρόβλημα Blocks World  είναι γνωστό και ως Sussman Anomaly. 

Λέγεται ανώμαλο διότι οι μη παρεμβαλλόμενοι σχεδιαστές των αρχών της δεκαετίας του 1970 δεν μπόρεσαν να λύσουν αυτό το πρόβλημα. Το πρόβλημα έχει ως εξής: Τρία μπλοκ με την ένδειξη "A", "B", "C" αφήνονται να ακουμπήσουν σε επίπεδη επιφάνεια. Η δεδομένη προϋπόθεση είναι ότι μόνο ένα μπλοκ μπορεί να μετακινηθεί κάθε φορά για την επίτευξη του στόχου. Η κατάσταση έναρξης και η τελική κατάσταση φαίνονται στο παρακάτω διάγραμμα. 

![world-blocks-planning.jpeg](data:image/jpeg;base64,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)

Η παρούσα εργασία υλοποιεί έναν πράκτορα που μπορεί να επιλύσει προβλήματα Block World με τον βέλτιστο τρόπο( στον ελάχιστο αριθμό κινήσεων) για μια αυθαίρετη αρχική διάταξη μπλοκ (A-Z, 26 μπλοκ μέγιστο). Η τεχνική πίσω απο τον πράκτορα είναι: Generate και Test για να δημιουργήοσυμε μια πιθανή κατάσταση και στην συνέχεια χρησιμοποιεί Means-Ends Analysis για να επιλέξει την καλύτερη κατάσταση να μετακινηθεί.

Ο πράκτορας σχεδιάστηκε για να προσπαθεί πάντα να μετακινεί πρώτα το επάνω μπλοκ της αριστερής στοίβας στη δεξιά στοίβα, ακολουθούμενο απο έλεγχο εάν η διαφορά έχει μειωθεί. Εάν ναι, τότε αυτή είναι η βέλτιστη κίνηση. Εάν όχι, τότε μετακινεί το επάνω μπλοκ στο τραπέζι, skipparei αν υπάρχει ήδη μπλοκ στον πίνακα και στην συνέχεια χρησιμοποιεί αυτήν την κατάσταση ως την νέα κατάσταση.

Ο πράκτορας θα διατηρήσει αυτήν την λειτουργία για κάθε μπλοκ της αριστερής στοίβας εως ότου η διαφορά φτάσει στο μηδέν, πράγμα που σημαίνει ότι έχει φτάσει στην κατάσταση στόχου. Μια τέτοια μέθοδος θα μπορούσε να διασφαλίσει οτι πάντα επιλέγονται οι βέλτιστες κινήσεις

Η μέθοδος επίλυσης θα πρέπει να λάβει σαν είσοδο 2 διευθετήσεις μπλοκ. Οι διευθετήσεις δίνονται σαν λίστες λιστών. Το πρώτο μπλοκ κάθε λίστας βρίσκεται στο τέλος της στοίβας και η λίστα συνεχίζει προς τα πάνω. Για παραδείγμα η λίστα [A,B,C] τοποθετεί το μπλοκ Β πάνω απο το Α και το C πανω απο Β, στην κορυφή δηλαδή.

Στόχος είναι να επιστρέψουμε μια λίστα κινήσεων που θα μετατρέψουν την αρχική κατάσταση στην κατάσταση στόχου.Οι κινήσεις παρουσιάζονται σαν 2 πλειάδες όπου το πρώτο αντικείμενο είναι ποιο μπλόκ θα μετακινήθει και το δεύτερο που θα μεταφερθεί: είτε πάνω απο κάποιο μπλοκ είτε στο τραπέζι.
"""

import copy
import string
import random

class BlocksWorld:

    def __init__(self):
        pass

    def solve(self, start, goal): 

        class State:
            def __init__(self, stack1, stack2, total, moves=None):
                if moves is None:
                    moves = []
                self.stack1 = stack1
                self.stack2 = stack2
                self.total= total
                self.moves = moves

            def __eq__(self, other):
                return (self.stack1 == other.stack1 and self.stack2 == other.stack2
                        and self.total == other.total and self.moves == other.moves)

            def goal_state_move(self):
                while self.difference() != 0:
                    self = self.select_move()
                return self.moves

            def select_move(self):  # tha epistrepsei thn kalyterh kinhsh
                #metakinisi teleutaiou block sthn stoiva
                #an den meiwthei h diafora, metakinisi sto trapezi
                for index, stack in enumerate(self.stack1):
                    for index2, stack2 in enumerate(self.stack1):
                        if index != index2:  
                            curr_table, move = self.valid_state_move(self.stack1, index, index2)
                            new_state = State(curr_table, self.stack2, self.total, copy.copy(self.moves))
                            new_state.moves.append(move)
                            if new_state.difference() < self.difference():
                                return new_state

                # metakinisi teleutaiou block sto trapezi
                # an vrisketai sto trapezi skip
                for index, stack in enumerate(self.stack1):
                    if len(stack) > 1:  
                        curr_table, move = self.valid_state_move(self.stack1, index, -1)  # -1 = trapezi
                        new_state = State(curr_table, self.stack2, self.total, copy.copy(self.moves))
                        new_state.moves.append(move)
                        if new_state.difference() <= self.difference():
                            return new_state

            def valid_state_move(self, table, start_index, end_index):
                temp_table = copy.deepcopy(table)
                left = temp_table[start_index]
                top_block = left.pop()
                right = []

                if end_index < 0:  # metakinisi sto trapezi (-1)
                    temp_table.append(right)
                    move = (top_block, 'Table')
                else:  # metakinisi stin stoiva
                    right = temp_table[end_index]
                    move = (top_block, right[-1])
                right.append(top_block)

                if len(left) == 0:
                    temp_table.remove(left)
                return temp_table, move

            def difference(self):
                same_num = 0
                # sygkrisi twn stoivwn
                for left in self.stack1:
                    for right in self.stack2:
                        index = 0
                        while index < len(left) and index < len(right):
                            if left[index] == right[index]:
                                same_num += 1
                                index += 1
                            else:
                                break
                diff = self.total - same_num
                return diff

        total = 0
        for l in start:
            for e in l:
                total += 1
        state = State(start, goal, total)
        solution = state.goal_state_move()

        return solution

test = BlocksWorld()


stacks = int(input("Eisagete arithmo stoivwn: "))
blocks = int(input("Eisagete arithmo block: "))

def startState(stacks, blocks):
  ls = stacks
  b = list(string.ascii_uppercase) #string.digits
  blocks_list = b[:blocks]
  random.shuffle(blocks_list)

  problem_state = []
  while blocks:
    if not blocks_list: break

    if stacks == 1:
       problem_state.append(blocks_list)
       break

    else:
      r = random.randint(1,blocks)
      s = blocks_list[:r]
      problem_state.append(s)

    blocks -=r
    stacks -= 1
    blocks_list = blocks_list[r:]
  while len(problem_state) < ls:
    problem_state += [[]]
  
  random.shuffle(problem_state)
  return problem_state


startSt = startState(stacks, blocks)

def goal_generator(startSt):
  goal = []
  for stack in startSt:
      goal += stack
  goal.sort()
  goal = [goal]

  for i in range(len(startSt)-1):
      goal += [[]]
  return goal

goalSt = goal_generator(startSt)


print("Start State: ", startSt)
print("Goal State: ", goalSt)
print("Lysh: ", test.solve(startSt, goalSt))

"""# **Water Jug Problem**

Στο πρόβλημα της κανάτας νερού στην Τεχνητή Νοημοσύνη, μας παρέχονται δύο κανάτες οι οποίες περιέχουν έναν γνωστό ακέραιο όγκο υγρού, όχι απαραίτητα ίσο με την χωρητικότητα της. Στόχος είναι να βρεθούν πόσα βήματα ρίψης νερού απο την μία κανάτα στην άλλη ( μέχρι να αδειάσει είτει η μια κανάτα είτε η άλλη να γεμίσει) για να επιτευχθεί η κατάσταση στόχου, που καθορίζεται απο τον χρήστη.

**Αναπαράσταση κατάστασης:**

Θα αντιπροσωπεύσουμε μια κατάσταση του προβλήματος ως πλειάδα (x,y) όπου το x αντιπροσωπεύει την ποσότητα νερού στην κανάτα Α  και το y αντιπροσωπεύει την ποσότητα στην κανάτα Β. 
Σημειώνεται ότι 0 <= x <= χωρητικότητα_y και 0 <= y <= χωρητικότητα_y.

**Κανόνες Παραγωγής:**

*   (x, y) -> (a, y) if x < a
*   (x, y) -> (x, b) if y < b
*   (x, y) -> (0, y) if x > 0
*   (x, y) -> (x, 0) if y > 0
*   (x, y) -> (min(x+y, a), max(0, x+y - a)) if y > 0
*  (x, y) -> (max(0, x+y - b), min(x+y, b)) if x > 0

Αυτοί οι κανόνες παραγωγής χρησιμοποιούνται για την εύρεση των γειτονικών καταστάσεων από τις τρέχουσες καταστάσεις.
Ο αλγόριθμος έχει ως εξής:





1.   Δημιουργία κενού μονοπατιού
2.   Προσθήκη αρχικής κατάστασης στην ουρά
3.   Αν επισκευτεί την μαρκάρουμε σαν visited
4.   Αν η front είνια κενή, ακολουθούμε τα βήματα 5-7
5.   Αφαιρούμε την κατάσταση απο την front και την ονομάζουμε current. Προσθέτουμε την current στην path list.
6.   Αναπτύσουμε τους γείτονες σύμφωνα με τους κανόνες παραγωγής.
7.   Αν οι γείτονες δεν είναι visited, τους προσθέτουμε στην λίστα visited και τους προσθέτουμε στην ουρά front
8.   Επιστρέφουμε το μονοπάτι

Ο χρήστης θα ορίσει ενα σύνολο τελεστών που θα μας μεταφέρουν απο την μία κατάσταση στην άλλη. 

Κανάτα Α: x γαλόνια νερού 

Κανάτα Β: y γαλόνια νερού

Στόχος: z γαλόνια σε μια κανάτα
"""

a_capacity = int(input("Xwritikotita kanatas A: "))
b_capacity = int(input("Xwritikotita kanatas B: "))
goal = int(input("Stoxos: "))

def gcd(a, b):
 if a == 0:
		 return b
 else:
	    return gcd(b%a, a)

def bfs(start, goal, a_capacity, b_capacity):
	path = []
	front = []
	front.append(start)
	visited = []
	#visited.append(start)
	while(not (not front)):
		current = front.pop()
		x = current[0]
		y = current[1]
		path.append(current)
		if x == goal or y == goal:
			print ("Vrethike Lysh")
			return path
		# kanonas 1
		if current[0] < a_capacity and ([a_capacity, current[1]] not in visited):
			front.append([a_capacity, current[1]])
			visited.append([a_capacity, current[1]])

		# kanonas 2
		if current[1] < b_capacity and ([current[0], b_capacity] not in visited):
			front.append([current[0], b_capacity])
			visited.append([current[0], b_capacity])

		# kanonas 3
		if current[0] > a_capacity and ([0, current[1]] not in visited):
			front.append([0, current[1]])
			visited.append([0, current[1]])

		# kanonas 4
		if current[1] > b_capacity and ([a_capacity, 0] not in visited):
			front.append([a_capacity, 0])
			visited.append([a_capacity, 0])

		# kanonas 5
		#(x, y) -> (min(x + y, a_capacity), max(0, x + y - a_capacity)) if y > 0
		if current[1] > 0 and ([min(x + y, a_capacity), max(0, x + y - a_capacity)] not in visited):
			front.append([min(x + y, a_capacity), max(0, x + y - a_capacity)])
			visited.append([min(x + y, a_capacity), max(0, x + y - a_capacity)])

		# kanonas 6
		# (x, y) -> (max(0, x + y - b_capacity), min(x + y, b_capacity)) if x > 0
		if current[0] > 0  and ([max(0, x + y - b_capacity), min(x + y, b_capacity)] not in visited):
			front.append([max(0, x + y - b_capacity), min(x + y, b_capacity)])
			visited.append([max(0, x + y - b_capacity), min(x + y, b_capacity)])

	return "Den vrethike"


# start state: a = 0 , b = 0
start = [0, 0] 


if goal % gcd(a_capacity,b_capacity) == 0:
	 print("Monopati:",bfs(start, goal, a_capacity, b_capacity))
else:
 	 print("Den vrethike lysh")

"""**ΠΕΡΙΓΡΑΦΗ ΛΥΣΗΣ**

*Αρχική Κατάσταση*: Κανάτα Α = 0 Κανάτα Β = 0 **[0,0]**

*Επόμενη Κατάσταση*: Γεμίζουμε την κανάτα Β **[0,3]**

*Επόμενη Κατάσταση*: Αδειάζουμε την κανάτα Α στην κανάτα Β **[3,0]**

*Επόμενη Κατάσταση*: Γεμίζουμε την κανάτα Β **[3,3]**

*Επόμενη Κατάσταση*: Γεμίζουμε την κανάτα Α ρίχνοντας 2 λίτρα απο την κανάτα Β **[5,1]**

*Επόμενη Κατάσταση*: Γεμίζουμε την κανάτα Β **[5,3]**

*Επόμενη Κατάσταση*: Αδειάζουμε την κανάτα Β καθώς έχουμε τα απαραίτητα λίτρα **[5,0]**

*Επόμενη Κατάσταση*:Γεμίζουμε την κανάτα Β μέχρι να έχουμε 2 λίτρα σε μία κανάτα **[2,3]** όπου είναι και ο τελικός μας στόχος.
"""